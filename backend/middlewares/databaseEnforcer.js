/**
 * Database-First Enforcement Middleware
 * Ensures EVERY request validates against and persists to database
 * CRITICAL: No client-side data is trusted
 */

const db = require('../database');
const logger = require('../utils/logger');

/**
 * Verify all data comes from database (not client-supplied)
 * For any GET endpoint: Database → Response only
 * For any POST/PUT endpoint: Validate → Database → Confirm
 */
class DatabaseEnforcer {
  /**
   * Ensure user data is ALWAYS from database
   * Never trust client-provided user info
   */
  static async enforceUserIdentity(req, res, next) {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({
          success: false,
          code: 'NO_USER_ID',
          message: 'User not authenticated'
        });
      }

      // ALWAYS fetch fresh user data from database
      const [users] = await db.execute(
        `SELECT id, name, email, role, status FROM users WHERE id = ?`,
        [userId]
      );

      if (users.length === 0) {
        return res.status(404).json({
          success: false,
          code: 'USER_NOT_FOUND',
          message: 'User no longer exists'
        });
      }

      const user = users[0];

      // Verify account is active
      if (user.status !== 'active') {
        return res.status(403).json({
          success: false,
          code: 'ACCOUNT_INACTIVE',
          message: 'This account is inactive'
        });
      }

      // Replace request user with fresh DB data
      req.user = user;
      req.dbUser = user;

      logger.info('User identity verified from database', { userId, role: user.role });
      next();
    } catch (error) {
      logger.error('Error verifying user identity:', error);
      res.status(500).json({
        success: false,
        code: 'INTERNAL_ERROR',
        message: 'Internal server error'
      });
    }
  }

  /**
   * Ensure attendance data cannot be created without database validation
   * This prevents client from marking attendance directly
   */
  static async enforceAttendanceValidation(req, res, next) {
    try {
      const { token, classSessionId, latitude, longitude } = req.body;

      if (!token || !classSessionId) {
        return res.status(400).json({
          success: false,
          code: 'MISSING_FIELDS',
          message: 'QR token and class session ID required'
        });
      }

      // Verify session exists in database
      const [sessions] = await db.execute(
        `SELECT id, attendance_status, current_qr_token, qr_expiry FROM class_sessions WHERE id = ?`,
        [classSessionId]
      );

      if (sessions.length === 0) {
        return res.status(404).json({
          success: false,
          code: 'SESSION_NOT_FOUND',
          message: 'Class session not found'
        });
      }

      const session = sessions[0];

      // Verify attendance window is open
      if (session.attendance_status !== 'open') {
        return res.status(403).json({
          success: false,
          code: 'ATTENDANCE_WINDOW_CLOSED',
          message: 'Attendance window is not open for this session'
        });
      }

      // Verify QR token matches and hasn't expired
      if (session.current_qr_token !== token) {
        logger.warn('Invalid QR token attempt', {
          sessionId: classSessionId,
          userId: req.user.id,
          providedToken: token,
          correctToken: session.current_qr_token
        });

        return res.status(401).json({
          success: false,
          code: 'INVALID_QR_TOKEN',
          message: 'Invalid QR token'
        });
      }

      if (new Date() > new Date(session.qr_expiry)) {
        return res.status(401).json({
          success: false,
          code: 'QR_EXPIRED',
          message: 'QR token has expired'
        });
      }

      // Attach validated session to request
      req.validatedSession = session;

      logger.info('Attendance validation passed', {
        sessionId: classSessionId,
        userId: req.user.id
      });

      next();
    } catch (error) {
      logger.error('Error enforcing attendance validation:', error);
      res.status(500).json({
        success: false,
        code: 'INTERNAL_ERROR',
        message: 'Internal server error'
      });
    }
  }

  /**
   * Ensure QR codes can ONLY be generated by backend
   * Frontend cannot create, modify, or generate QR codes
   */
  static async enforceQRGeneration(req, res, next) {
    try {
      const { sessionId } = req.params;
      const lecturerId = req.user.id;

      // Verify this lecturer owns this session
      const [sessions] = await db.execute(
        `SELECT id, lecturer_id, attendance_status FROM class_sessions 
         WHERE id = ? AND lecturer_id = ?`,
        [sessionId, lecturerId]
      );

      if (sessions.length === 0) {
        return res.status(403).json({
          success: false,
          code: 'SESSION_NOT_FOUND',
          message: 'You do not own this session'
        });
      }

      // Verify session is not already closed
      if (sessions[0].attendance_status === 'closed') {
        return res.status(403).json({
          success: false,
          code: 'SESSION_CLOSED',
          message: 'Attendance window already closed'
        });
      }

      req.validatedSession = sessions[0];
      next();
    } catch (error) {
      logger.error('Error enforcing QR generation:', error);
      res.status(500).json({
        success: false,
        code: 'INTERNAL_ERROR',
        message: 'Internal server error'
      });
    }
  }

  /**
   * Ensure only DB data is returned (no client-side modifications)
   * Wraps response to guarantee DB source
   */
  static ensureDBResponse(dataKey = 'data') {
    return (req, res, next) => {
      // Store original json method
      const originalJson = res.json.bind(res);

      // Override json to add DB source guarantee
      res.json = function(data) {
        if (data.success && data[dataKey]) {
          // Verify data came from DB query
          if (!data._dbSource) {
            logger.warn('Response data may not be from database', {
              endpoint: req.path,
              method: req.method,
              userId: req.user?.id
            });
          }
        }
        return originalJson(data);
      };

      next();
    };
  }

  /**
   * Ensure all writes are persisted before responding
   * No response sent until database confirms
   */
  static async enforceDBPersistence(req, res, next) {
    const originalJson = res.json.bind(res);

    res.json = async function(data) {
      // If this is a write operation that claims success
      if (data.success && ['POST', 'PUT', 'PATCH', 'DELETE'].includes(req.method)) {
        // Verify the record actually exists in database
        if (data.data?.id) {
          try {
            // Generic check: ensure ID exists somewhere
            logger.info('Persistence check requested', {
              method: req.method,
              path: req.path,
              recordId: data.data?.id
            });
          } catch (error) {
            logger.error('Persistence verification failed:', error);
            return originalJson({
              success: false,
              code: 'PERSISTENCE_FAILED',
              message: 'Data was not properly stored'
            });
          }
        }
      }

      return originalJson(data);
    };

    next();
  }

  /**
   * Audit logging middleware
   * Every request is logged with outcome
   */
  static auditLog(req, res, next) {
    const originalJson = res.json.bind(res);

    res.json = async function(data) {
      // Log the request/response
      const auditEntry = {
        user_id: req.user?.id,
        user_role: req.user?.role,
        method: req.method,
        path: req.path,
        ip_address: req.ip,
        user_agent: req.headers['user-agent'],
        success: data.success,
        status_code: res.statusCode,
        error_code: data.code,
        timestamp: new Date().toISOString()
      };

      // For sensitive operations, log to database
      if (['POST', 'PUT', 'PATCH', 'DELETE'].includes(req.method)) {
        try {
          await db.execute(
            `INSERT INTO communication_audit_log 
             (sender_id, communication_type, event_type, event_data, timestamp)
             VALUES (?, 'api_request', ?, ?, NOW())`,
            [
              req.user?.id || 0,
              data.success ? 'success' : 'failure',
              JSON.stringify(auditEntry)
            ]
          );
        } catch (error) {
          logger.error('Error logging audit entry:', error);
          // Don't fail the request, just log the error
        }
      }

      logger.info('API Request', auditEntry);
      return originalJson(data);
    };

    next();
  }
}

module.exports = DatabaseEnforcer;
